


# IdentityExp1

An Asp.Net Core implementation of Microsoft Identity, without using EntityFramework, but using MS SQL Server, for JWTs, with Roles and Claims.



## Intro

This is an AspNetCore project in Visual Studio 2017, Work In Progress, Not Yet Complete, but functional.

This project is an exploration of a prototype API Identity Server, using JSON Web Tokens (JWTs), without using Entity Framework, but using Microsoft's Identity APIs.
The Identity Server's aim is to purely authenticate user credentials, and issue access and refresh tokens, with claims sourced from roles.
Token usage reduces hits on the user database, and outboards the user storage to a distinct server, taking some of the load and code out of an application.
Tokens can also be used by websites, desktop and mobile apps, allowing the application server to worry about just supplying data, separation of concerns and all that.

The Identity store uses SQL Express with a database called CustomIdentity.

HTTPS (SSL) is implemented as a mandatory constraint.  Encrypt all the things.

Rate Limiting is available but can be turned off by removing options from the appsettings.json file.

This treatment does not consider 3rd party authentication ie Facebook logins, it is more a learning exercise for token usage.  
If you have never used tokens before, and want to have a single way for all platforms to authenticate to an app server, this could be useful.

Cookies are not used, the tokens are expected to be held in the Authorization header eg. "Authorization:Bearer <access_token>"

[A complementary project, LoginWithJwtExp1, exists, which shows how to create a website that uses JWTs for authentication, and roles to protect API endpoints.]



## Getting Started

Fork and Clone, and open the SLN solution file using VS 2017.  

Set a System-wide environment variable called CORE_IDENTITYEXP1 to hold a string of 16 chars or greater, which will act as the entropy seed for a symmetric secret key.
The app consuming the tokens generated by this Identity Server will need to know the same key to decrypt tokens.  
I will looking into asymmetric security using private-public key pairs in future.

Check the appsettings.json file for the AccessValidFor and RefreshValidFor settings, and configure these to the values you expect to use.  
See below for an explanation of tokens, and what values to use, if you are not familiar with the ideas.



## Deployment

The system requires a database to be set up, running on MS SQL Server.  The SQL server is used primarily as a store, and the SQL is not complex, so there should be little dependency on the SQL version.  For reference I am using SQL Server Express 2008.

The database is called CustomIdentity, and scripts are provided in the SqlScripts directory to create the database and tables.  Once the database has been created, you will need to set up a User who has full rights to the database, and that user will have to be referenced in the ConnectionString.  Do not use SA.

When the application starts first time, it will attempt to connect to the database.  If it connects successfully, it checks for some users with some roles, and if it does not find them, it creates them.  The users are Admin, Alice, Bob and Charles.  The roles are ADMIN and USER.  Passwords default to "test123" for all users.  If you are trying to set up the system, you will know it has worked if you have data in the AspNetUsers, AspNetRoles and AspNetUserRoles tables.

You can change this in your fork of course, but you will at least need an Admin user with a known default password, a role called ADMIN, and this Admin user should be assigned the ADMIN role by the app.  This will allow you to make calls to the API endpoints to create new users, and it will also mean that the default password is not stored in the database in clear text.



### Connection String Passwords

The appsettings.json file has a ConnectionStrings section, with an entry for CustomIdentity.  Here you can specify your connection string, which points to the server, database, user ID and, normally, password.  

In this case I am not using the password in the connection string.  Instead, I am storing the name of a Windows Environment Variable that the system will use to look up the password.  

The environment variable name is PasswordEnvVar, and I have called the environment variable CORE_DB.  
You can change CORE_DB to obfuscate the fact that this is a password, whatever you set PasswordEnvVar to will be used as the environment variable used to store the password.  
If you are using my example, ensure that you set up a SQL user for the database, give the user full rights, and then set the password, and store the password in the CORE_DB environment variable.



## Access Tokens and Refresh Tokens

Tokens are Json Web Tokens.  They are JSON string objects with two properties, the encrypted token data, and the expiration.  The encrypted token data contains all the info about the user, and the claims for the user.



### Access Tokens

Access Tokens have a property "access_token", and an "expires_in" property.

Access tokens are short-lived tokens that hold the claims for an identity (user).
The client application (website server, desktop app, mobile app) sends the access token to the Application server whenever it interacts with the Application.
The Application server decrypts the token using the symmetric key, and if it is valid, it trusts the claims in the token.  
In this implementation, the claims are just the roles the user has been assigned.

The Access token cannot be cancelled, so it is short lived, and must be re-requested regularly before it expires.
Each time the access token is generated, the database is checked for claims, so if a role is revoked, the maximum time for the revoke to take effect is the lifetime of the access token.

I would suggest a minimum of 30 seconds for sensitive, highly secure apps, and up to 5 minutes for less secure apps.  It should be long enough that you are not continuously refreshing tokens from the database, but short enough that if the token is hijacked, it will expire before the bad actor can maliciously exploit the token.  Once the token is obtained by a bad actor, they can act as the user, so the access token should expire before damage can be done.



### Refresh Tokens

Refresh Tokens have a property "refresh_token", and an "expires_in" property.

The refresh token is used to generate new access tokens.
Each refresh token is tagged with the User ID, and given a unique ID.  
The refresh token also notes the request IP address, and binds the token to that IP address.  
This improves security, but if the client's IP address changes, they will be forced to re-request tokens from the Issue endpoint.
The benefit is that a stolen refresh token can only be used from a machine with a matching IP address.

The refresh token is long-lived.  It is re-issued with a new expiration each time the Refresh endpoint is called.
This provides a 'sliding window' of authentication, similar to a 'session'.
Effectively the authentication session will time out if there is no Refresh request made for lifetime of the refresh token, but if the user keeps interacting with the system and refreshing the token, the session will extend indefinitely.  

The refresh token lifetime should always be longer than the access token lifetime.  It should be long enough that the user is not continuously being asked to log in again, but short enough that if you block a user, the block will take effect in a reasonable time, when the next refresh token is requested.  



## API Endpoints

There are two main API endpoints:

 * api/jwt/issue
 * api/jwt/refresh
 
Issue endpoint takes credentials and sends back an access and refresh token.
Refresh endpoint takes a refresh token and sends back a new access and refresh token.

Note: More API endpoints will be written for creating and administering users, which will wrap the UserManager functions in MS Identity.  This is work in progress.



### Issue API Endpoint 

 * POST http://localhost:61368/api/jwt/issue  
 * UserName=Alice&Password=test123 

The issue endpoint checks the posted request and extracts the UserName and Password data.
This is checked against the database using MS Identity UserManager, and if UserManager validates the password, tokens are issued.

The access token is intended to be used directly by the client application.
It is short lived, with the intention being that if it is compromised, it quickly becomes invalid and requires re-issuing via the refresh endpoint, or re-authentication.



### Refresh API Endpoint

 * POST http://localhost:61368/api/jwt/refresh 
 * sRefreshToken=eyJhbGciOiJIUzI1NiIsInR5cC... 

The refresh endpoint allows anonymous access, and so your access token can be allowed to fully expire before attempting to get a refreshed token pair.

If the refresh token is valid, the database is checked for current role claims, and new access and refresh tokens are issued, sliding their expiration forward in time.

The refresh token should be stored securely by the client application.
If a refresh token is compromised or stolen, it can be used to obtain new access tokens until it expires.
As such, when using tokens with websites, the refresh token should only be held on the server side, and not stored in a cookie on the web page, or in local storage.
When the web-site server application detects a stale access token, it can retrieve the cached request token and request a new access token from the Identity server.



## Logging and Email

The system uses Log4Net with simple file logging.  I have found the Core MS Logging Extensions have been extremely slow, as they seem to use reflection, so I have a wrapper to work around that.

Also, the system uses MailKit for emailing, and the appsettings.json file is used to hold the email settings. 



## Tests

A test project is included to work the Issue and Refresh Controller endpoints.



### Token Blacklists Are Not Required

Whilst tokens cannot be cancelled, the user is re-checked for claims with each call to obtain a refresh token.
The client application server can apply the condition that any sensitive endpoints require the 'USER' role, and then if a user must be blocked, this role can be revoked.  
When the Refresh endpoint is called, the claims are re-pulled from the database, and the user will not be given a valid claim to the 'USER' role, and the Application server will therefore block access.

The lifetime of the Access Token therefore sets how long the administrator has to wait for the block to take effect.  It is therefore a good idea to make this time short, but not
so short that you spam the Identity server.  For a sensitive app, the order of 30 seconds to 60 seconds might be sane.  For a non-critical applications, 5 or 10 minutes might be good.  It is a call for the administrator to make.



### IP Address Binding

When the Issue endpoint is called, the Refresh token is built.  
Inside that token, the IP address of the connection making the request is recorded, and stored in the database.
When the Refresh Token is received at the Refresh endpoint, the token is validated to ensure it has not been tampered with, and the IP address recorded in it is compared to the expected IP address in the database.  
If there is a mis-match, the refresh is rejected and the user must re-authenticate with credentials via the Issue endpoint.

This is designed to prevent token theft.  Normally, posession of a token is enough to assert identity, but this design is an attempt to improve security and prevent someone hijacking a Refresh Token.
It is acknowledged that this does not stop malicious code hijacking the token on the same client machine, or deal with IP address spoofing.  
Also, it will be inconvenient for any situation where the IP address is constantly changing.  
It should be relatively simple to comment out the code that checks the IP address against the database, if this is causing problems (in the JwtController.Refresh() function).

Suggestions for security improvements will be welcomed and, of course, acknowledged.



### Sharing the Identity Server Across Multiple Applications

Roles are not very sophisticated, but are simple and can be useful.  As the role name is just a string, a single Identity server could serve multiple applications by dot-delimiting the roles.  
For example, if you have AppA and AppB, each with their own role requirements, but you want to use a single login for them, you could set roles to be "APPA.USER" and "APPB.USER".
This allows a single identity to have different privileges on different applications, and does not require additional coding.
The consuming application must just be written to protect endpoints with roles that include it's own application name.



### Rate Limiting

Stefan Prodan's AspNetCoreRateLimit code has been used to prevent malicious or accidental spamming of the two critical endpoints, Issue and Refresh.
The implementation uses the IPRateLimit Middleware only, as this combines IP address and UserID to build an identity.

Rate Limiting can be turned off by removing options from the appsettings.json file.  
The rate limiting Middleware code initially checks for valid options and shortcuts out if none are set.



## Acknowledgements and Credits

The Identity code comes from Matthew King's IdentityWithoutEF project:
https://github.com/MatthewKing/IdentityWithoutEF

The JWT code originated with William Hallat's JWT treatment:
https://goblincoding.com/2016/07/03/issuing-and-authenticating-jwt-tokens-in-asp-net-core-webapi-part-i/

The AspNetCoreRateLimit code is from Stefan Prodan's project:
https://github.com/stefanprodan/AspNetCoreRateLimit




## License

Please use this code in any way you see fit, but if you can, document the credit of the Matthew King, Stefan Prodan, William Hallat, and myself.

Attribution-ShareAlike 4.0 International

If you make significant commercial gain, please donate to...

   https://www.facebook.com/secondchancetasman/

... or a similar local animal welfare charity.  