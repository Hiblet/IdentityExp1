


# IdentityExp1

This is an AspNetCore project in Visual Studio 2017, Work In Progress, Not Yet Complete

This project is an exploration of a prototype API Identity Server, using JSON Web Tokens (JWTs), without using Entity Framework, but using Microsoft's Identity APIs.
The Identity Server's aim is to purely authenticate user credentials, and issue access and refresh tokens, with claims sourced from roles.
Token usage reduces hits on the user database, and outboards the user storage to a distinct server, taking some of the load and code out of an application.
Tokens can also be used by websites, desktop and mobile apps, allowing the application server to worry about just supplying data, separation of concerns and all that.

The Identity store uses a simple memory record that is wiped on each run, so that you can use this as a start point to adapt it for your own persistence layer or ORM.

HTTPS (SSL) is implemented as a mandatory constraint.  Encrypt all the things.

Rate Limiting is available but can be turned off by removing options from the appsettings.json file.

This treatment does not consider 3rd party authentication ie Facebook logins, it is more a learning exercise for token usage.  
If you have never used tokens before, and want to have a single way for all platforms to authenticate to an app server, this could be useful.

Cookies are not used, the tokens are expected to be held in the Authorization header eg. "Authorization:Bearer <access_token>"



## Getting Started

Fork and Clone, and open the sln solution file using VS 2017.  Not sure about VS Code, I am Windows-based, with apologies.

Set a System-wide environment variable called CORE_IDENTITYEXP1 to hold a string of 16 chars or greater, which will act as the entropy seed for a symmetric secret key.
The app consuming the tokens generated by this Identity Server will need to know the same key to decrypt tokens.  
I will looking into asymmetric security using private-public key pairs in future.

Check the appsettings.json file for the AccessValidFor and RefreshValidFor settings, and configure these to the values you expect to use.  
See below for an explanation of tokens, and what values to use, if you are not familiar with the ideas.



## Deployment

The system is not intended for deployment in a real scenario.
You will be needing a real database implementation, not a memory store.



## Access Tokens and Refresh Tokens

These are JWTs, JSON string object with two properties, the encrypted token data, and the expiration.



### Access Tokens

Access Tokens have a property "access_token", and an "expires_in" property.

Access tokens are short-lived tokens that hold the claims for an identity (user).
The client application (website server, desktop app, mobile app) sends the access token to the Application server whenever it interacts with the Application.
The Application server decrypts the token using the symmetric key, and if it is valid, it trusts the claims in the token.  
In this implementation, the claims are just the roles the user has been assigned.

The Access token cannot be cancelled, so it is short lived, and must be re-requested regularly before it expires.
Each time the access token is generated, the database is checked for claims, so if a role is revoked, the maximum time for the revoke to take effect is the
lifetime of the access token.



### Refresh Tokens

Refresh Tokens have a property "refresh_token", and an "expires_in" property.

The refresh token is used to generate new access tokens.
Each refresh token is tagged with the User ID, and given a unique ID.  
The refresh token also notes the request IP address, and binds the token to that IP address.  
This improves security, but if the client's IP address changes, they will be forced to re-request tokens from the Issue endpoint.
The benefit is that a stolen refresh token can only be used from a machine with a matching IP address.

The refresh token is long-lived.  It is re-issued with a new expiration each time the Refresh endpoint is called.
This provides a 'sliding window' of authentication.
Effectively the authentication session will time out if there is no Refresh request made for lifetime of the refresh token.

The refresh token lifetime should always be longer than the access token lifetime.



## API Endpoints

There are two API endpoints:

 *api/jwt/issue*
 *api/jwt/refresh*
 
Issue endpoint takes credentials and sends back an access and refresh token.
Refresh endpoint takes a refresh token and sends back a new access and refresh token.



### Issue API Endpoint 

* POST http://localhost:61368/api/jwt/issue *
* UserName=Alice&Password=test123 *

The issue endpoint checks the posted request and extracts the UserName and Password data.
This is checked against the faux database using MS Identity UserManager, and if UserManager validates the password, tokens are issued.

The access token is intended to be used directly by the client application.
It is short lived, with the intention being that if it is compromised, it quickly becomes invalid and requires re-issuing via the refresh endpoint, or re-authentication.



### Refresh API Endpoint

* POST http://localhost:61368/api/jwt/refresh *
* sRefreshToken=eyJhbGciOiJIUzI1NiIsInR5cC... *

The refresh endpoint is only available if a valid access token is presented in the header "Authorize: Bearer <access_token>" .
The refresh endpoint should therefore be called before the access token expires.

If the access token and refresh token are both valid, the database is checked for current role claims, and new tokens are issued, 
sliding their expiration forward in time.

The refresh token should be stored securely by the client application.
If it is compromised or stolen, it can be used to obtain new access tokens until it expires.
As such, when using tokens with websites, the refresh token should only be held on the server side.
When the web page application detects a stale access token, it can request a new access token from the server, and the server can use
the securely stored refresh token to obtain a new access token on behalf of the web page.



## Tests

A test project is included to work the Issue and Refresh Controller endpoints.



## Notes



### Token Blacklists Not Required

Whilst tokens cannot be cancelled, the user is re-checked for claims with each call to Refresh.
The Application server can apply the condition that any sensitive endpoints require the 'USER' role, and then if a user must be blocked, this role can be revoked.  
When the Refresh endpoint is called, the claims are re-pulled from the database, and the user will not be given a valid claim to the 'USER' role,
and the Application server will therefore block access.

The lifetime of the Access Token therefore sets how long the administrator has to wait for the block to take effect.  It is therefore a good idea to make this time short, but not
so short that you spam the Identity server.  For a sensitive app, the order of 30 seconds to 60 seconds might be sane.  
For a non-critical applications, 5 or 10 minutes might be good.  It is a call for the administrator to make.



### IP Address Binding

When the Issue endpoint is called, the Refresh token is built.  
Inside that token, the IP address of the connection making the request is recorded, and stored in the faux database.
When the Refresh Token is received at the Refresh endpoint, the token is validated to ensure it has not been tampered with, and the IP address recorded in it is compared to the expected IP address in the database.  
If there is a mis-match, the refresh is rejected and the user must re-authenticate with credentials via the Issue endpoint.

This is designed to prevent token theft.  Normally, posession of a token is enough to assert identity, but this design is an attempt to improve security and prevent someone hijacking a Refresh Token.
It is acknowledged that this does not stop malicious code hijacking the token on the same client machine, or deal with IP address spoofing.  
Also, it will be inconvenient for any situation where the IP address is constantly changing.  
It should be relatively simple to comment out the code that checks the IP address against the database, if this is causing problems (in the JwtController.Refresh() function).

Suggestions for security improvements will be welcomed and, of course, acknowledged.



### Sharing the Identity Server Across Multiple Applications

Roles are not very sophisticated, but are simple and can be useful.  As the role name is just a string, a single Identity server could serve multiple applications by dot-delimiting the roles.  
For example, if you have AppA and AppB, each with their own role requirements, but you want to use a single login for them, you could set roles to be "APPA.USER" and "APPB.USER".
This allows a single identity to have different privileges on different applications, and does not require additional coding.
The consuming application must just be written to protect endpoints with roles that include it's own application name.



### Rate Limiting

Stefan Prodan's AspNetCoreRateLimit code has been used to prevent malicious or accidental spamming of the two critical endpoints, Issue and Refresh.
The implementation uses the IPRateLimit Middleware only, as this combines IP address and UserID to build an identity.

Rate Limiting can be turned off by removing options from the appsettings.json file.  
The rate limiting Middleware code initially checks for valid options and shortcuts out if none are set.



## Acknowledgements and Credits

The Identity code comes from Matthew King's IdentityWithoutEF project:
https://github.com/MatthewKing/IdentityWithoutEF

The JWT code originated with William Hallat's JWT treatment:
https://goblincoding.com/2016/07/03/issuing-and-authenticating-jwt-tokens-in-asp-net-core-webapi-part-i/

The AspNetCoreRateLimit code is from Stefan Prodan's project:
https://github.com/stefanprodan/AspNetCoreRateLimit




## License

Please use this code in any way you see fit, but if you can, document the credit of the Matthew King and William Hallat, and myself.

Attribution-ShareAlike 4.0 International

If you make significant commercial gain, please donate to...

   https://www.facebook.com/secondchancetasman/

... or a similar local animal welfare charity.